{
    "functionPSUtils": {
        "prefix": "function",
        "body": [
            "function Verb-Noun {",
            "\t[CmdletBinding()]",
            "\tparam (",
            "\t\t[Parameter(Mandatory)] [ValidateSet(\"Appels\", \"Peren\")] [string] $$ParameterName,",
            " [Parameter(Mandatory = $$true)]\r",
            " [ArgumentCompleter( {\r",
            " param ( $$commandName, $$parameterName, $$wordToComplete, $$commandAst, $$fakeBoundParameters )\r",
            " Get-ChildItem \"$($Path)\\$wordToComplete*\" -Directory -Name | ForEach-Object { \"`\"$$_`\"\" } }\r",
            " )]\r",
            " [ValidateScript( {\r",
            " $$_ -in (Get-ChildItem \"$($Path)\" -Directory -Name)\r",
            " } ) ]\r",
            " [string] $$WindowsVersion\r",
            "\t)\r\r",
            "}\r"
        ],
        "description": "Create function"
    },
    "RequiresAdmin": {
        "prefix": "reqadmin",
        "description": "PowerShell #Requires Statements",
        "body": [
            "#Requires -RunAsAdministrator"
        ]
    },
    "CompletionScript": {
        "prefix": "comp",
        "description": "completion snippet",
        "body": [
            "# ------------------------------------------",
            "# $1 PowerShell Completion Script",
            "# ------------------------------------------",
            "",
            "If (Get-Command $2 -ErrorAction SilentlyContinue) {",
            "$3",
            "}"
        ]
    },
    "Generic Header": {
        "prefix": "header",
        "description": "Add simple header to source files.",
        "body": [
            "# ------------------------------------------",
            "# File  : $TM_FILENAME",
            "# Author: Jimmy Briggs",
            "# Title :",
            "# ------------------------------------------",
            "",
            ""
        ]
    },
    "Script Header": {
        "prefix": "header_",
        "description": "Output a file header with the file name, comment field, author and date",
        "body": [
            "#$TM_FILENAME",
            "",
            "<#",
            "",
            "",
            "Jimmy Briggs",
            "$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE",
            "#>",
            "",
            ""
        ]
    },
    "New Type Accelerator": {
        "prefix": "newaccel",
        "body": [
            "\\$xlr=[psobject].Assembly.GetType('System.Xml.XmlDocument')",
            "\\$xlr::Add('xml',\\$xlr)",
            "\\$xmlobject = [xml]::new()",
            "$0"
        ],
        "description": "New Type Accelerator"
    },
    "Add To EnvPath": {
        "prefix": "addtopath",
        "body": [
            "if (\\$env:Path[-1] -eq \";\") {",
            "    \\$env:Path = \"\\$env:Path\\$MSBuildParentDir\"",
            "}",
            "else {",
            "    \\$env:Path = \"\\$env:Path;\\$MSBuildParentDir\"",
            "}",
            "$0"
        ],
        "description": "Add to EnvPath"
    },
    "Array": {
        "prefix": "arr",
        "body": [
            "\\$array = @(",
            "    \"obj1\"",
            "    \"obj2\"",
            "    \"obj3\"",
            ")",
            "",
            "# Delete old \\$array object and create new \\$array object with same name and string \"obj4\" added",
            "\\$array += \"obj4\"",
            "",
            "# Delete old \\$array object and create new \\$array object with the same name while retaining the",
            "# original object (and its type/property info) as opposed to simply adding the object's value to the array",
            "\\$array +=, \\$obj5",
            "# As a result of the above, assuming that \\$obj5.GetType().Name -eq \"DirectoryInfo\",",
            "# \\$array[4].GetType().Name should also -eq \"DirectoryInfo\" as opposed to \"String\" or some other type.",
            "",
            "# Convert Array to Systems.Collection.ArrayList to allow use of Add/Remove Methods",
            "# The Add/Remove Methods simply modify the existing [System.Collection.ArrayList] as opposed to destroying",
            "# and creating a new one with the same name",
            "[System.Collection.ArrayList]\\$newarray = \\$array",
            "\\$newarray.Add(\"obj6\")",
            "\\$newarray.Remove(\"obj6\")",
            "$0"
        ],
        "description": "Array"
    },
    "Background Job": {
        "prefix": "bgjobscript",
        "body": [
            "Start-Job -Name myJob -InitializationScript {Import-Module BitsTransfer} -FilePath myFile.ps1",
            "$0"
        ],
        "description": "Background Job"
    },
    "Begin": {
        "prefix": "beg",
        "body": [
            "begin {",
            "}",
            "$0"
        ],
        "description": "Begin"
    },
    "Bound Parameters": {
        "prefix": "boundparams",
        "body": [
            "\\$BoundParamsArrayOfKVP = \\$PSBoundParameters.GetEnumerator() | foreach {\\$_}",
            "$0"
        ],
        "description": "Bound Parameters"
    },
    "Cmdlet Binding": {
        "prefix": "cmdletbinding",
        "body": [
            "[CmdletBinding(",
            "    DefaultParameterSetName='Parameter Set 1',",
            "    SupportsShouldProcess=\\$true,",
            "    PositionalBinding=\\$false,",
            "    HelpUri = 'http://www.microsoft.com/',",
            "    SupportsPaging = \\$false,",
            "    ConfirmImpact='Medium'",
            ")]",
            "[Alias('vn','verbn','vnoun')]",
            "[OutputType([String])]",
            "$0"
        ],
        "description": "Cmdlet Binding"
    },
    "String To ScriptBlock": {
        "prefix": "stringtoscript",
        "body": [
            "\\$scriptBlock = [scriptblock]::Create(\\$string)",
            "$0"
        ],
        "description": "String To ScriptBlock"
    },
    "Temp File Or Dir": {
        "prefix": "tempitem",
        "body": [
            "#\\$tmpDir = [IO.Path]::GetTempPath()",
            "#\\$tmpFile = [IO.Path]::GetTempFileName()",
            "",
            "\\$tempfile = [IO.Path]::Combine([IO.Path]::GetTempPath(), [IO.Path]::GetRandomFileName())",
            "New-Item -Type File -path \\$tempfile",
            "",
            "\\$tempDirectory = [IO.Path]::Combine([IO.Path]::GetTempPath(), [IO.Path]::GetRandomFileName())",
            "[IO.Directory]::CreateDirectory(\\$tempDirectory)",
            "$0"
        ],
        "description": "Temp File or Dir"
    },
    "New Html Dom Object": {
        "prefix": "htmlobj",
        "body": [
            "if (Test-Path \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\Microsoft.mshtml.dll\") {",
            "    Add-Type -Path \"C:\\Program Files (x86)\\Microsoft.NET\\Primary Interop Assemblies\\Microsoft.mshtml.dll\"",
            "}",
            "elseif (Test-Path \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\PublicAssemblies\\Microsoft.mshtml.dll\") {",
            "    Add-Type -Path \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\IDE\\PublicAssemblies\\Microsoft.mshtml.dll\"",
            "}",
            "else {",
            "    Invoke-WebRequest -Uri \"http://packages.nuget.org/api/v1/package/Unofficial.Microsoft.mshtml\" -OutFile \"\\$HOME\\Downloads\\Unofficial.Microsoft.mshtml.zip\"",
            "    Expand-Archive -Path \"\\$HOME\\Downloads\\Unofficial.Microsoft.mshtml.zip\" -DestinationPath \"\\$HOME\\Downloads\\Unofficial-Microsoft-mshtml\"",
            "    \\$mshtmlDLLPath = \\$(Get-ChildItem \\$HOME\\Downloads\\Unofficial-Microsoft-mshtml\\ -Recurse | Where-Object {\\$_.Name -eq \"Microsoft.mshtml.dll\"}).FullName",
            "    Add-Type -Path \\$mshtmlDLLPath",
            "}",
            "",
            "\\$RawHtml = @\"",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
            "<html xmlns=\"http://www.w3.org/1999/xhtml\">",
            "<head>",
            "    <style>",
            "        TABLE {border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}",
            "        TH {border-width: 1px;padding: 3px;border-style: solid;border-color: black;background-color: #6495ED;}",
            "        TD {border-width: 1px;padding: 3px;border-style: solid;border-color: black;}",
            "        .odd  { background-color:#ffffff; }",
            "        .even { background-color:#dddddd; }",
            "        TR:Nth-Child(Even) {Background-Color: #dddddd;}",
            "        TR:Hover TD {Background-Color: #C1D5F8;}",
            "    </style>",
            "</head>",
            "<body>",
            "    <h2>Call Count For December</h2>",
            "    <h4>This Report Has Been Saved To \"C:\\Users\\pddomain\\CallActivityReportDecember.html\"</h4>",
            "    <h3>Total Number of Calls for filter  is 26</h3>",
            "    <table>",
            "        <colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup>",
            "        <tr><th>Date/Time</th><th>Duration</th><th>Call Type</th><th>From</th><th>To</th><th>Acct. Code</th><th>FromPhoneNumber</th><th>FromName</th><th>FromExt</th><th>ToPhoneNumber</th><th>ToName</th><th>ToExt</th><th>ToGroup</th><th>ToVoicemail</th><th>ToForwardedCall</th></tr>",
            "        <tr><td>12/31/2016 12:27:48 PM</td><td>00:00:14</td><td>Incoming</td><td>(610) 733-8293 Consign FIELD MARY&quot; &quot;</td><td>6106478632</td><td>1</td><td>6107338293</td><td>Consign FIELD MARY</td><td></td><td>6106478632</td><td></td><td>6106478632</td><td></td><td></td><td>6106478632</td></tr>",
            "    </table>",
            "    <h3>Report Run on 04/19/2017 08:26:40</h3>",
            "</body>",
            "</html>",
            "\"@",
            "",
            "\\$NewHTMLObject = New-Object mshtml.HTMLDocumentClass",
            "\\$ConvertToHtmlObj = Import-Clixml -Path \"C:\\Users\\pddomain\\CallCountReportObj.xml\"",
            "\\$ConvertToHtmlObjAsString = \\$ConvertToHtmlObj.ToString()",
            "\\$NewHTMLObject.IHTMLDocument2_write(\\$ConvertToHtmlObjAsString)",
            "$0"
        ],
        "description": "New Html Dom Object"
    },
    "This Script Dir": {
        "prefix": "thisscriptdir",
        "body": [
            "\\$ScriptDir = \\$PSCommandPath | Split-Path -Parent",
            "\\$ScriptFile = \\$PSCommandPath | Split-Path -Leaf",
            "$0"
        ],
        "description": "This Script Dir"
    },
    "Current User": {
        "prefix": "currentuser",
        "body": [
            "[System.Security.Principal.WindowsIdentity]::GetCurrent()",
            "$0"
        ],
        "description": "Current User"
    },
    "Do Until": {
        "prefix": "dountil",
        "body": [
            "do",
            "{",
            "    \\$1",
            "} until (\\$x -gt 0)"
        ],
        "description": "Do Until"
    },
    "Do While": {
        "prefix": "dowhile",
        "body": [
            "do",
            "{",
            "    \\$1",
            "} while (\\$true)"
        ],
        "description": "Do While"
    },
    "DSC Class-Based Resource Provider": {
        "prefix": "dscprovclass",
        "body": [
            "[DscResource()]",
            "class NameOfResource {",
            "    [DscProperty(Key)]",
            "    [string] \\$KeyName",
            "",
            "    # Gets the resource's current state.",
            "    [NameOfResource] Get() {",
            "        return \\$this",
            "    }",
            "",
            "    # Sets the desired state of the resource.",
            "    [void] Set() {",
            "    }",
            "",
            "    # Tests if the resource is in the desired state.",
            "    [bool] Test() {",
            "    }",
            "}",
            "$0"
        ],
        "description": "DSC Class-Based Resource Provider"
    },
    "DSC Config Example": {
        "prefix": "dscconfigexamp",
        "body": [
            "configuration Name",
            "{",
            "    # One can evaluate expressions to get the node list",
            "    # E.g: .Where(\"Role -eq Web\").NodeName",
            "    node (\"Node1\",\"Node2\",\"Node3\")",
            "    {",
            "        # Call Resource Provider",
            "        # E.g: WindowsFeature, File",
            "        WindowsFeature FriendlyName",
            "        {",
            "            Ensure = \"Present\"",
            "            Name = \"Feature Name\"",
            "        }",
            "",
            "        File FriendlyName",
            "        {",
            "            Ensure = \"Present\"",
            "            SourcePath =",
            "            DestinationPath =",
            "            Type = \"Directory\"",
            "           DependsOn = \"[WindowsFeature]FriendlyName\"",
            "        }",
            "    }",
            "}",
            "$0"
        ],
        "description": "DSC Config Example"
    },
    "DSC Function-Based Resource Provider": {
        "prefix": "dscprovfun",
        "body": [
            "Function Get-TargetResource",
            "{",
            "    # TODO: Add parameters here",
            "    # Make sure to use the same parameters for",
            "    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
            "    param(",
            "    )",
            "}",
            "",
            "Function Set-TargetResource",
            "{",
            "    # TODO: Add parameters here",
            "    # Make sure to use the same parameters for",
            "    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
            "    param(",
            "    )",
            "}",
            "",
            "Function Test-TargetResource",
            "{",
            "    # TODO: Add parameters here",
            "    # Make sure to use the same parameters for",
            "    # Get-TargetResource, Set-TargetResource, and Test-TargetResource",
            "    param(",
            "    )",
            "}",
            "$0"
        ],
        "description": "DSC Function-Based Resource Provider"
    },
    "Set-PSDebug": {
        "prefix": "setdebug",
        "body": [
            "Set-PSDebug -Step; foreach (\\$i in 1..3) {\\$i}",
            "$0"
        ],
        "description": "Set-PSDebug"
    },
    "Environment Special Directory Documents": {
        "prefix": "mydocs",
        "body": [
            "\\$MyDocs = [Environment]::GetFolderPath([Environment+SpecialFolder]::MyDocuments)"
        ],
        "description": "Environment Special Directory Documents"
    },
    "Error": {
        "prefix": "error",
        "body": [
            "if (! \\$(Test-Path \\$SamplePath)) {",
            "    Write-Error \"The path \\$SamplePath was not found! Halting!\"",
            "    \\$global:FunctionResult = \"1\"",
            "    return",
            "}",
            "$0"
        ],
        "description": "Error"
    },
    "Validate Path": {
        "prefix": "validatepath",
        "body": [
            "# FOR THE LOVE OF GOD, USE: https://regex101.com to figure out regex",
            "",
            "# \\$RegexURL comes from: http://daringfireball.net/2010/07/improved_regex_for_matching_urls",
            "# Distill one or more strings that are valid paths from unknown object",
            "\\$RegexLocalOrUNCPath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))(((?![<>:\"\\/\\\\\\\\|?*]).)+((?<![ .])\\\\\\\\)?)*\\$'",
            "\\$RegexURL = \"(?i)\\b((?:https?://|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'`\".,<>?«»“”‘’]))\"",
            "",
            "\\$RegexDirectoryPath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))((?![.<>:\"\\/\\\\\\\\|?*]).)+((?![.<>:\"\\/|?*]).)+\\$'",
            "\\$RegexFilePath = '^(([a-zA-Z]:\\\\\\\\)|(\\\\\\\\\\\\\\\\))((?![.<>:\"\\/\\\\\\\\|?*]).)+((?![<>:\"\\/|?*]).)+((.*?\\.)|(.*?\\.[\\w]+))+\\$'",
            "",
            "# Invalid FileName Characters",
            "\\$InvalidFileNameChars = [System.IO.Path]::GetInvalidFileNameChars()",
            "\\$InvalidFileNameChars = \\$InvalidFileNameChars | foreach {if ($_ -eq '\\\\') {'\\\\\\\\'} else {$_}}",
            "\\$InvalidFileNameChars | foreach {",
            "    if (\\$FileName -match $_) {",
            "        Write-Error \"The filename for the shortcut (i.e. \\$FileName) contains an illegal character '\\$_' ! Halting!",
            "        \\$global:FunctionResult = \"1\"",
            "        return",
            "    }",
            "}",
            "",
            "# Finding potential Local or UNC in a block of text",
            "\\$TextBlock = Get-Content \\$HOME\textblock.txt",
            "\\$PotentialPathsArray = \\$(\\$TextBlock | Select-String -Pattern \\$RegexLocalOrUNCPath -AllMatches).Matches.Value",
            "\\$UpdatedPotentialPathsArray = foreach (\\$potentialpath in \\$PotentialPathsArray) {",
            "    if (\\$([uri]\\$potentialpath).IsAbsoluteURI -and \\$(\\$([uri]\\$potentialpath).IsLoopBack -or \\$([uri]\\$potentialpath).IsUnc)) {",
            "        \\$potentialpath",
            "    }",
            "}",
            "",
            "# Validating a string that is supposed to be a Local or UNC Path",
            "if ( !\\$(\\$([uri]\\$TargetDir).IsAbsoluteURI -and \\$(\\$([uri]\\$TargetDir).IsLoopBack -or \\$([uri]\\$TargetDir).IsUnc)) ) {",
            "    Write-Error \"\\$TargetDir is not a valid directory path! Halting!\"",
            "    \\$global:FunctionResult = \"1\"",
            "    return",
            "}",
            "",
            "# Determine if string is a URL, a local path, or a UNC path",
            "if ([uri]\\$TargetString.Scheme -match \"http\") {",
            "    Write-Host \"\\$TargetSring is a URL\"",
            "}",
            "if ([uri]\\$TargetString.Scheme -eq \"file\" -and [uri]\\$TargetString.Host -ne \\$null) {",
            "    Write-Host \"\\$TargetString is a UNC path\"",
            "}",
            "if ([uri]\\$TargetString.Scheme -eq \"file\" -and [uri]\\$TargetString.Host -eq \\$null) {",
            "    Write-Host \"\\$TargetString is a local path\"",
            "}",
            "$0"
        ],
        "description": "Validate Path"
    },
    "For Loop": {
        "prefix": "for",
        "body": [
            "for (\\$i=0; \\$i -lt \\$array.Count; \\$i++) {",
            "",
            "}",
            "$0"
        ],
        "description": "For Loop"
    },
    "ForEach": {
        "prefix": "foreach",
        "body": [
            "foreach (\\$item in \\$collection) {",
            "",
            "}",
            "$0"
        ],
        "description": "ForEach"
    },
    "Function Block Advanced": {
        "prefix": "funadv",
        "body": [
            "<#",
            ".SYNOPSIS",
            "    Short description",
            ".DESCRIPTION",
            "    Long description",
            ".NOTES",
            "    DEPENDENCEIES",
            "        Helper scripts/functions and/or binaries needed for the function to work.",
            ".PARAMETER",
            "    N parameter",
            ".PARAMETER",
            "    N+1 parameter",
            ".EXAMPLE",
            "    Example of how to use this cmdlet",
            ".EXAMPLE",
            "    Another example of how to use this cmdlet",
            ".INPUTS",
            "    Inputs to this cmdlet (if any)",
            ".OUTPUTS",
            "    Output from this cmdlet (if any)",
            "#>",
            "",
            "function Verb-Noun {",
            "    [CmdletBinding(",
            "        DefaultParameterSetName='Parameter Set 1',",
            "        PositionalBinding=\\$true,",
            "        ConfirmImpact='Medium'",
            "    )]",
            "    [Alias('vn','verbn','vnoun')]",
            "",
            "    <#",
            "    All PS 5.1 Parameter Arguments and Attributes are as follows:",
            "    (See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters)",
            "",
            "        Arguments:",
            "        Syntax is, for example -",
            "        [parameter(Mandatory=\\$true,Position=1)])",
            "",
            "        Mandatory, Position, ParameterSetName, ValueFromPipeline, ValueFromPipelineByPropertyName,",
            "        ValueFromRemainingArguments, HelpMessage",
            "",
            "        Attributes:",
            "        Syntax is somewhere immediately before the parameter name, for example -",
            "        [Alias(\"CN\",\"MachineName\")]",
            "        \\$ComputerName",
            "",
            "        Alias, AllowNull, AllowEmptyString, AllowEmptyCollection, ValidateCount, ValidateLength,",
            "        ValidatePattern, ValidateRange, ValidateScript, ValidateSet, ValidateNotNull,",
            "        ValidateNotNullOrEmpty",
            "    #>",
            "",
            "    Param(",
            "        [Parameter(",
            "            Mandatory=\\$False,",
            "            ParameterSetName='Parameter Set 1'",
            "        )]",
            "        [Alias(\"helperdir\")]",
            "        [string]\\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
            "",
            "        [Parameter(",
            "            Mandatory=\\$False,",
            "            ParameterSetName='Parameter Set 1'",
            "        )]",
            "        [Alias(\"outdir\")]",
            "        [string]\\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
            "    )",
            "",
            "    # Adding the Dynamic Parameter \"dp1\" that is revealed via tab completion if \\$OutputDirectory matches \"C:\\boop\"",
            "    DynamicParam {",
            "        if (\\$OutputDirectory -match \"C:\\boop\") {",
            "            \\$attributes = New-Object System.Management.Automation.ParameterAttribute",
            "            \\$attributes.ParameterSetName = \"__AllParameterSets\"",
            "            \\$attributes.Mandatory = \\$false",
            "",
            "            \\$attributeCollection = New-Object -Type System.Collections.ObjectModel.Collection",
            "            [System.Attribute]\\$attributeCollection.Add(\\$attributes)",
            "",
            "            \\$dynParam1 = New-Object -Type System.Management.Automation.RuntimeDefinedParameter(\"dp1\", [Int32], \\$attributeCollection)",
            "",
            "            \\$paramDictionary = New-Object -Type System.Management.Automation.RuntimeDefinedParameterDictionary",
            "            \\$paramDictionary.Add(\"dp1\", \\$dynParam1)",
            "            return \\$paramDictionary",
            "        }",
            "    }",
            "",
            "    ##### REGION Helper Functions and Libraries #####",
            "",
            "    ## BEGIN Sourced Helper Functions ##",
            "",
            "    ## END Sourced Helper Functions ##",
            "",
            "    ## BEGIN Native Helper Functions ##",
            "",
            "    ## END Native Helper Functions ##",
            "",
            "    ##### REGION END Helper Functions and Libraries #####",
            "",
            "",
            "    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "    ##### END Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "",
            "    ##### BEGIN Parameter Validation #####",
            "",
            "    ##### END Parameter Validation #####",
            "",
            "",
            "    ##### BEGIN Main Body #####",
            "",
            "    ##### END Main Body #####",
            "",
            "}",
            "$0"
        ],
        "description": "Function Block Advanced"
    },
    "Function Block Advanced Complete": {
        "prefix": "funadvcom",
        "body": [
            "<#",
            ".SYNOPSIS",
            "    Short description",
            ".DESCRIPTION",
            "    Long description",
            ".NOTES",
            "    DEPENDENCIES",
            "        Helper scripts/functions and/or binaries needed for the function to work.",
            ".PARAMETER",
            "    N parameter",
            ".PARAMETER",
            "    N+1 parameter",
            ".EXAMPLE",
            "    Example of how to use this cmdlet",
            ".EXAMPLE",
            "    Another example of how to use this cmdlet",
            ".INPUTS",
            "    Inputs to this cmdlet (if any)",
            ".OUTPUTS",
            "    Output from this cmdlet (if any)",
            ".COMPONENT",
            "    The component this cmdlet belongs to",
            ".ROLE",
            "    The role this cmdlet belongs to",
            ".FUNCTIONALITY",
            "    The functionality that best describes this cmdlet",
            "#>",
            "function Verb-Noun {",
            "    [CmdletBinding(",
            "        DefaultParameterSetName='Parameter Set 1', ",
            "        SupportsShouldProcess=\\$true, ",
            "        PositionalBinding=\\$false,",
            "        HelpUri = 'http://www.microsoft.com/',",
            "        SupportsPaging = \\$false,",
            "        ConfirmImpact='Medium'",
            "    )]",
            "    [Alias('vn','verbn','vnoun')]",
            "    [OutputType([String])]",
            "",
            "    <#",
            "    All PS 5.1 Parameter Arguments and Attributes are as follows:",
            "    (See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters)",
            "    ",
            "        Arguments:",
            "        Syntax is, for example -",
            "        [parameter(Mandatory=\\$true,Position=1)])",
            "",
            "        Mandatory, Position, ParameterSetName, ValueFromPipeline, ValueFromPipelineByPropertyName,",
            "        ValueFromRemainingArguments, HelpMessage",
            "        ",
            "        Attributes:",
            "        Syntax is somewhere immediately before the parameter name, for example -",
            "        [Alias(\"CN\",\"MachineName\")]",
            "        \\$ComputerName",
            "",
            "        Alias, AllowNull, AllowEmptyString, AllowEmptyCollection, ValidateCount, ValidateLength,",
            "        ValidatePattern, ValidateRange, ValidateScript, ValidateSet, ValidateNotNull,",
            "        ValidateNotNullOrEmpty",
            "    #>",
            "",
            "    Param",
            "    (",
            "        # \\$HelperFunctionSourceDirectory help description",
            "        [Parameter(",
            "            Mandatory=\\$true, ",
            "            ValueFromPipeline=\\$true,",
            "            ValueFromPipelineByPropertyName=\\$true, ",
            "            ValueFromRemainingArguments=\\$false, ",
            "            Position=0,",
            "            ParameterSetName='Parameter Set 1'",
            "        )]",
            "        [ValidateNotNull()]",
            "        [ValidateNotNullOrEmpty()]",
            "        [ValidateCount(0,5)]",
            "        [ValidateSet(\"sun\", \"moon\", \"earth\")]",
            "        [Alias(\"hfsd\")] ",
            "        [string]\\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
            "",
            "        # \\$Number help description",
            "        [Parameter(",
            "            Position=1,",
            "            ParameterSetName='Parameter Set 1'",
            "        )]",
            "        [AllowNull()]",
            "        [AllowEmptyCollection()]",
            "        [AllowEmptyString()]",
            "        [ValidateScript({\\$true})]",
            "        [ValidateRange(0,5)]",
            "        [int]\\$Number,",
            "",
            "        [Parameter(",
            "            Position=2,",
            "            ParameterSetName='Another Parameter Set'",
            "        )]",
            "        [ValidatePattern(\"[a-z]*\")]",
            "        [ValidateLength(0,15)]",
            "        [string]\\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
            "",
            "        # \\$IPAddress help description",
            "        [Parameter(",
            "            Position=3,",
            "            ParameterSetName='Another Parameter Set'",
            "        )]",
            "        [ValidateScript({",
            "            \\$_ -match [IPAddress]",
            "        })]",
            "        \\$IPAddress",
            "    )",
            "",
            "    # Adding the Dynamic Parameter \"dp1\" that is revealed via tab completion if \\$OutputDirectory matches \"C:\\boop\"",
            "    DynamicParam {",
            "        if (\\$OutputDirectory -match \"C:\\boop\") {",
            "            \\$attributes = New-Object System.Management.Automation.ParameterAttribute",
            "            \\$attributes.ParameterSetName = \"__AllParameterSets\"",
            "            \\$attributes.Mandatory = \\$false",
            "",
            "            \\$attributeCollection = New-Object -Type System.Collections.ObjectModel.Collection",
            "            [System.Attribute]\\$attributeCollection.Add(\\$attributes)",
            "",
            "            \\$dynParam1 = New-Object -Type System.Management.Automation.RuntimeDefinedParameter(\"dp1\", [Int32], \\$attributeCollection)",
            "",
            "            \\$paramDictionary = New-Object -Type System.Management.Automation.RuntimeDefinedParameterDictionary",
            "            \\$paramDictionary.Add(\"dp1\", \\$dynParam1)",
            "            return \\$paramDictionary",
            "        }",
            "    }",
            "",
            "    Begin {",
            "    ##### REGION Helper Functions and Libraries #####",
            "",
            "    ## BEGIN Sourced Helper Functions ##",
            "",
            "    ## END Sourced Helper Functions ##",
            "",
            "    ## BEGIN Native Helper Functions ##",
            "",
            "    ## END Native Helper Functions ##",
            "",
            "    ##### REGION END Helper Functions and Libraries #####",
            "",
            "",
            "    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "    ##### END Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "",
            "    ##### BEGIN Parameter Validation #####",
            "",
            "    ##### END Parameter Validation #####",
            "    }",
            "",
            "    Process {",
            "        if (\\$pscmdlet.ShouldProcess(\"Target\")) {",
            "        ##### BEGIN Main Body #####",
            "",
            "        ##### END Main Body #####",
            "        }",
            "    }",
            "",
            "    End {",
            "        ##### BEGIN Cleanup #####",
            "",
            "        ##### END Cleanup #####",
            "    }",
            "}",
            "$0"
        ],
        "description": "Function Block Advanced Complete"
    },
    "Function Block Simple": {
        "prefix": "funsim",
        "body": [
            "# For more advanced PowerShell Function Parameter Arguments and Attributes, see:",
            "# https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters",
            "",
            "function Verb-Noun",
            "{",
            "    [CmdletBinding()]",
            "    [Alias('vn','verbn','vnoun')]",
            "    Param( ",
            "        [Parameter(Mandatory=\\$False)]",
            "        \\$HelperFunctionSourceDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory that contains the [HELPER] script(s)/function(s)\"),",
            "        [Parameter(Mandatory=\\$False)]",
            "        \\$OutputDirectory = \\$(Read-Host -Prompt \"Please enter the full path to the directory where all output files will be written\")",
            "",
            "    )",
            "",
            "    ##### REGION Helper Functions and Libraries #####",
            "",
            "    ## BEGIN Sourced Helper Functions ##",
            "",
            "    ## END Sourced Helper Functions ##",
            "",
            "    ## BEGIN Native Helper Functions ##",
            "",
            "    ## END Native Helper Functions ##",
            "",
            "    ##### REGION END Helper Functions and Libraries #####",
            "",
            "",
            "    ##### BEGIN Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "    ##### END Variable/Parameter Transforms and PreRun Prep #####",
            "",
            "",
            "    ##### BEGIN Parameter Validation #####",
            "",
            "    ##### END Parameter Validation #####",
            "",
            "",
            "    ##### BEGIN Main Body #####",
            "",
            "    ##### END Main Body #####",
            "",
            "}",
            "$0"
        ],
        "description": "Function Block Simple"
    },
    "Get Registered COM Classes": {
        "prefix": "comobject",
        "body": [
            "# Get All Available Com Objects",
            "\\$GetComClasses = gwmi -Class win32_classiccomclasssetting -ComputerName .",
            "\\$GetComClasses | Where-Object {\\$_.progid -like \"*html*\"}",
            "",
            "# Create New Com Object by referencing ProgID",
            "\\$NewHTMLObject = New-Object -ComObject \"htmlfile\"",
            "",
            "# Create New Com Object by referencing GUID",
            "\\$clsid = New-Object Guid '25336920-03F9-11cf-8FD0-00AA00686F13'",
            "\\$type = [Type]::GetTypeFromCLSID(\\$clsid)",
            "\\$NewHTMLObject = [Activator]::CreateInstance(\\$type)",
            "$0"
        ],
        "description": "Get Registered COM Classes"
    },
    "Get-Member All": {
        "prefix": "gm",
        "body": [
            "\\$test | Get-Member -View All -Force",
            "$0"
        ],
        "description": "Get-Member All"
    },
    "GUI Choose From List": {
        "prefix": "guichoice",
        "body": [
            "\\$ChoiceOptions = @(1,2,3)",
            "\\$DefaultChoice = 0",
            "\\$ChoiceDescription = New-Object System.Collections.ObjectModel.Collection[System.Management.Automation.Host.ChoiceDescription]",
            "\\$ChoiceOptions | foreach  {",
            "    \\$ChoiceDescription.Add(",
            "        (New-Object \"System.Management.Automation.Host.ChoiceDescription\" -ArgumentList \\$_)",
            "    )",
            "}",
            "\\$Host.ui.PromptForChoice(\"Caption\", \"message\", \\$ChoiceDescription, \\$DefaultChoice)",
            "$0"
        ],
        "description": "GUI Choose From List"
    },
    "GUI Message Box": {
        "prefix": "guimsgbox",
        "body": [
            "\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms').FullName",
            "[void][reflection.assembly]::Load(\\$AssemblyFullInfo)",
            "[void][System.Windows.Forms.MessageBox]::Show(Text,Caption)",
            "$0"
        ],
        "description": "GUI Message Box"
    },
    "GUI Message Box Yes No": {
        "prefix": "guimsgboxyesno",
        "body": [
            "\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Windows.Forms').FullName",
            "[void][reflection.assembly]::Load(\\$AssemblyFullInfo)",
            "if ([System.Windows.Forms.MessageBox]::Show(\"Question\", \"Caption\",[System.Windows.Forms.MessageBoxButtons]::YesNo) -eq \"Yes\")",
            "{",
            "}",
            "$0"
        ],
        "description": "GUI Message Box Yes No"
    },
    "Hashtable": {
        "prefix": "hashtable",
        "body": [
            "@{",
            "    key = \"value\"",
            "    key = 0",
            "}",
            "$0"
        ],
        "description": "Hashtable"
    },
    "Help Block": {
        "prefix": "helpblock",
        "body": [
            "<#",
            ".SYNOPSIS",
            "    Short description",
            ".DESCRIPTION",
            "    Long description",
            ".NOTES",
            "    DEPENDENCEIES",
            "        Helper scripts/functions and/or binaries needed for the function to work.",
            ".PARAMETER",
            "    N parameter",
            ".PARAMETER",
            "    N+1 parameter",
            ".EXAMPLE",
            "    Example of how to use this cmdlet",
            ".EXAMPLE",
            "    Another example of how to use this cmdlet",
            ".INPUTS",
            "    Inputs to this cmdlet (if any)",
            ".OUTPUTS",
            "    Output from this cmdlet (if any)",
            "#>",
            "$0"
        ],
        "description": "Help Block"
    },
    "Install MSI": {
        "prefix": "installmsi",
        "body": [
            "\\$DataStamp = Get-Date -Format yyyyMMddTHHmmss",
            "\\$MSIFullPath = \"\\$HOME\\Downloads\\GitDesktop.msi\"",
            "\\$MSIParentDir = \\$MSIFullPath | Split-Path -Parent",
            "\\$MSIFileName = \\$MSIFullPath | Split-Path -Leaf",
            "\\$MSIFileNameOnly = \\$MSIFileName -replace \"\\.msi\",\"\"",
            "\\$logFile = \"\\$MSIFileNameOnly\\$DataStamp.log\"",
            "\\$MSIArguments = @(",
            "    \"/i\"",
            "    \\$MSIFullPath",
            "    \"/qn\"",
            "    \"/norestart\"",
            "    \"/L*v\"",
            "    \\$logFile",
            ")",
            "Start-Process \"msiexec.exe\" -ArgumentList \\$MSIArguments -Wait -NoNewWindow",
            "$0"
        ],
        "description": "Install MSI"
    },
    "List Type Accelerators": {
        "prefix": "getaccel",
        "body": [
            "\\$xlr=[psobject].Assembly.GetType('System.Management.Automation.TypeAccelerators')",
            "\\$xlr::Add('accelerators',\\$xlr)",
            "# The below \\$accelerators is a System.Collections.Generic.Dictionary`2",
            "\\$accelerators = [accelerators]::get",
            "# To change \\$accelerators to an object that the Where-Object cmdlet works against, do the following:",
            "[System.Collections.Hashtable] = \\$accelerators",
            "\\$acceleratorsEnum = \\$accelerators.GetEnumerator()",
            "\\$acceleratorsEnum | Where-Object {\\$_.Name -eq \"pscustomobject\"}",
            "$0"
        ],
        "description": "Install MSI"
    },
    "Module Manifest": {
        "prefix": "modulemanifest",
        "body": [
            "# For more information, see: https://msdn.microsoft.com/en-us/powershell/reference/4.0/microsoft.powershell.core/new-modulemanifest",
            "\\$ModuleName = \"UserSessionEx\"",
            "",
            "\\$Params = @{",
            "    Path = \"\\$(\\$(Get-Location).Path)\\\\$ModuleName.psd1\"",
            "    Author = \"pldmgg\"",
            "    ModuleToProcess = \".\\\\$ModuleName.psm1\"",
            "    CompanyName = \"Boop\"",
            "    FunctionsToExport = \"Get-UserSessionViaQuery\",\"Get-UserSessionViaCim\",\"Get-WsManServerInfo\",\"Get-UserSessionEx\"",
            "    Description = \"Get all available User Session information for one or more hosts\"",
            "    FileList = \"\\$ModuleName.psm1\",\"\\$ModuleName.psd1\"",
            "    HelpInfoUri = \"http://pldmgg.github.io/misc-powershell\"",
            "    LicenseUri = \"http://www.apache.org/licenses/LICENSE-2.0\"",
            "    ModuleVersion = \"0.9\"",
            "    PowerShellVersion = \"5.0\"",
            "}",
            "New-ModuleManifest @Params",
            "$0"
        ],
        "description": "Module Manifest"
    },
    "Filter Block": {
        "prefix": "filter",
        "body": [
            "Filter FilterName {",
            "    if (\\$_ -eq 2) {",
            "        \\$_",
            "        break",
            "    }",
            "}",
            "@(1,2,3) | FilterName",
            "$0"
        ],
        "description": "Filter Block"
    },
    "Download NuGet Package": {
        "prefix": "nugetdl",
        "body": [
            "Write-Host \"Downloading \\$assembly...\"",
            "\\$NewAssemblyDir = \"\\$HOME\\Downloads\\\\$assembly\"",
            "\\$NewAssemblyDllPath = \"\\$NewAssemblyDir\\\\$assembly.dll\"",
            "if (!\\$(Test-Path \\$NewAssemblyDir)) {",
            "    New-Item -ItemType Directory -Path \\$NewAssemblyDir",
            "}",
            "if (Test-Path \"\\$NewAssemblyDir\\\\$assembly*.zip\") {",
            "    Remove-Item \"\\$NewAssemblyDir\\\\$assembly*.zip\" -Force",
            "}",
            "\\$OutFileBaseNamePrep = Invoke-WebRequest \"https://www.nuget.org/api/v2/package/\\$assembly\" -DisableKeepAlive -UseBasicParsing",
            "\\$OutFileBaseName = \\$(\\$OutFileBaseNamePrep.BaseResponse.ResponseUri.AbsoluteUri -split \"/\")[-1] -replace \"nupkg\",\"zip\"",
            "Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/\\$assembly\" -OutFile \"\\$NewAssemblyDir\\\\$OutFileBaseName\"",
            "if (\\$PSVersionTable.PSEdition -eq \"Core\") {",
            "    foreach (\\$subdir in \\$PotentialZipSubDirs) {",
            "        try {",
            "            Unzip-File -PathToZip \"\\$NewAssemblyDir\\\\$OutFileBaseName\" -TargetDir \\$NewAssemblyDir -SpecificItem \"\\$subdir\\\\$assembly.dll\"",
            "            if (\\$?) {",
            "                \\$FoundSubdir = \\$true",
            "            }",
            "        }",
            "        catch {",
            "            Write-Error \"\\$subdir\\\\$assembly.dll not found...\"",
            "        }",
            "",
            "        if (\\$FoundSubdir) {",
            "            break",
            "        }",
            "    }",
            "}",
            "$0"
        ],
        "description": "Download NuGet Package"
    },
    "Function Parameters": {
        "prefix": "params",
        "body": [
            "# See: https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.core/about/about_functions_advanced_parameters",
            "[Parameter(",
            "    Mandatory=\\$False,",
            "    Position=0,",
            "    ParameterSetName='Parameter Set 1',",
            "    ValueFromPipeline=\\$true,",
            "    ValueFromPipelineByPropertyName=\\$true,",
            "    ValueFromRemainingArguments=\\$false,",
            "    HelpMessage=\"Enter one or more directory paths names separated by commas.\"",
            ")]",
            "[Alias(\"asdf\")]",
            "[AllowNull()]",
            "[AllowEmptyString()]",
            "[AllowEmptyCollection()]",
            "[ValidateCount(0,5)]",
            "[ValidateLength(1,10)]",
            "[ValidatePattern(\"[a-z]*\")]",
            "[ValidateRange(0,5)]",
            "[ValidateScript({\\$true})]",
            "[ValidateSet(\"sun\",\"moon\",\"earth\")]",
            "[ValidateNotNull()]",
            "[ValidateNotNullOrEmpty()]",
            "[string]\\$WorkingDir,",
            "$0"
        ],
        "description": "Function Parameters"
    },
    "Ping W PowerShell": {
        "prefix": "ping",
        "body": [
            "Test-Connection -Count 9999 -ComputerName COMPUTERNAME | Format-Table @{Name='TimeStamp';Expression={Get-Date}},Address,ProtocolAddress,ResponseTime",
            "$0"
        ],
        "description": "Ping W PowerShell"
    },
    "Process Start": {
        "prefix": "processstart",
        "body": [
            "\\$ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo",
            "\\$ProcessInfo.FileName = \"ssh.exe\"",
            "\\$ProcessInfo.RedirectStandardError = \\$true",
            "\\$ProcessInfo.RedirectStandardOutput = \\$true",
            "\\$ProcessInfo.UseShellExecute = \\$false",
            "\\$ProcessInfo.Arguments = \"-T git@github.com\"",
            "\\$Process = New-Object System.Diagnostics.Process",
            "\\$Process.StartInfo = \\$ProcessInfo",
            "\\$Process.Start() | Out-Null",
            "\\$Process.WaitForExit()",
            "\\$stdout = \\$Process.StandardOutput.ReadToEnd()",
            "\\$stderr = \\$Process.StandardError.ReadToEnd()",
            "\\$AllOutput = \\$stdout + \\$stderr",
            "$0"
        ],
        "description": "Process Start"
    },
    "Proxy Function": {
        "prefix": "proxyfunction",
        "body": [
            "function Get-ProcessBetter {",
            "    <#",
            "        For more information about proxy functions, see the following article on the",
            "        Microsoft PowerShell Team blog:",
            "        http://blogs.msdn.com/powershell/archive/2009/01/04/extending-and-or-modifing-commands-with-proxies.aspx",
            "    #>",
            "    <#",
            "        To create a proxy function for the Get-Process cmdlet, paste the results of the following command into the body of this function and then remove this comment:",
            "        [Management.Automation.ProxyCommand]::Create((New-Object Management.Automation.CommandMetaData (Get-Command Get-Process)))",
            "    #>",
            "}",
            "$0"
        ],
        "description": "Proxy Function"
    },
    "PS Credential": {
        "prefix": "pscred",
        "body": [
            "\\$Credentials = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList \\$UserName, \\$Pwd",
            "$0"
        ],
        "description": "PS Credential"
    },
    "PS Custom Object": {
        "prefix": "psobject",
        "body": [
            "New-Variable -Name \"VariableName\" -Value \\$(",
            "    [pscustomobject][ordered]@{",
            "        Key1   = \"Value1\"",
            "        Key2   = \"Value2\"",
            "        Key3   = \"Value3\"",
            "    }",
            ")",
            "$0"
        ],
        "description": "PS Custom Object"
    },
    "PowerShell Class": {
        "prefix": "psclass",
        "body": [
            "# http://powershelldistrict.com/powershell-class/",
            "Class Computer {",
            "    [String]\\$Name",
            "    [String]\\$Type",
            "    [string]\\$Description",
            "    [string]\\$owner",
            "    [string]\\$Model",
            "    [int]\\$Reboots",
            "",
            "    # Method",
            "    [void]Reboot(){",
            "        \\$this.Reboots ++",
            "    }",
            "",
            "    # Class Constructor (one way of instantiating a new object)",
            "    Computer ([string]\\$Name){",
            "        if (\\$comp = Get-ADComputer -filter \"name -eq '\\$Name'\" -Properties * -ErrorAction SilentlyContinue){",
            "            \\$this.name =\\$Name",
            "            \\$this.Description = \\$Comp.Description",
            "",
            "            switch -wildcard (\\$comp.OperatingSystem){",
            "                ('*Server*') {\\$this.Type = 'Server';Break}",
            "                ('*workstation*') {\\$this.Type = 'Workstation'}",
            "                ('*Laptop*') {\\$this.Type = 'Laptop';Break}",
            "                default { \\$this.Type = 'N/A'}",
            "            ",
            "            }",
            "           \\$this.owner = \\$comp.ManagedBy.Split(',')[0].replace('CN=','')",
            "        }else{",
            "            write-verbose \"Could Not find \\$(\\$this.name)\"",
            "        }",
            "        ",
            "    }",
            "",
            "    # Class Constructor (another way of instantiating a new object)",
            "    Computer ([string]\\$Name, [String]\\$type,[string]\\$Description,[string]\\$owner,[String]\\$Model){",
            "        if (!(\\$comp = Get-ADComputer -filter \"name -eq '\\$Name'\" -Properties name)){",
            " ",
            "            ",
            "            if (\\$user = Get-ADUser -Filter \"name -eq '\\$owner'\"){",
            "            ",
            "                try{",
            "                   New-ADComputer -Name \\$Name -Description \\$Description -ManagedBy \\$user -ErrorAction Stop",
            "                    \\$this.Name = \\$Name",
            "                    \\$this.Type = \\$type",
            "                    \\$this.Description = \\$Description",
            "                    \\$this.owner = \\$owner     ",
            "                }catch{",
            "                    \\$_",
            "                } ",
            "            }else{",
            "                write-warning \"the user \\$(\\$Owner) is not existing. Please verify and try again.\"",
            "            }",
            "        }",
            "        ",
            "    }",
            "}",
            "$0"
        ],
        "description": "PowerShell Class"
    },
    "Random String": {
        "prefix": "randstring",
        "body": [
            "# Letters only 10 characters long:",
            "\\$randstring = -join ((1..10) | %{(65..90) + (97..122) | Get-Random} | % {[char]\\$_})",
            "",
            "# Letters and numbers 10 characters long",
            "\\$randstring = -join (0..10 | % {[char][int]((65..90) + (97..122) + (48..57) | Get-Random)})",
            "",
            "# Letters, numbers, and symbols 10 characters long",
            "\\$randstring = -join (0..10 | % {[char][int]((65..90) + (97..122) + (48..57) + (35,36,42,43,44,45,46,47,58,59,61,63,64,91,92,93,95,123,125,126) | Get-Random)})",
            "$0"
        ],
        "description": "Random String"
    },
    "Registry Management": {
        "prefix": "registry",
        "body": [
            "<#",
            "Registry PropertyType Reference:",
            "",
            "REG_SZ = String ",
            "REG_DWORD = DWord ",
            "REG_QWORD = QWord ",
            "REG_MULTI_SZ = MultiString ",
            "REG_BINARY = Binary",
            "#>",
            "",
            "if (!\\$(Test-Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation)) {",
            "    New-Item -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation",
            "}",
            "if (!\\$(Test-Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefaultCredentials)) {",
            "    New-Item -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation\\AllowDefaultCredentials",
            "}",
            "Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name AllowFreshCredentials -Value 1 -Type DWord",
            "Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name ConcatenateDefaults_AllowFresh -Value 1 -Type DWord",
            "Set-ItemProperty -Path HKLM:\\Software\\Policies\\Microsoft\\Windows\\CredentialsDelegation -Name 1 -Value WSMAN/\\$env:COMPUTERNAME.\\$(\\$(Get-CimInstance -ClassName Win32_ComputerSystem).Domain) -Type String",
            "$0"
        ],
        "description": "Registry Management"
    },
    "Resolve Path": {
        "prefix": "resolvepath",
        "body": [
            "if (-not (Test-Path \\$Path)) {",
            "    New-Item -ItemType Directory -Path \\$Path -ErrorAction Stop | Out-Null",
            "}",
            "\\$FinalPath = (Resolve-Path \\$Path -ErrorAction Stop).ProviderPath",
            "$0"
        ],
        "description": "Resolve Path"
    },
    "CSharp": {
        "prefix": "csharp",
        "body": [
            "# NuGet Packages downloaded/installed via Visual Studio Project can be found here:",
            "# \\$HOME\\.nuget\\packages",
            "",
            "###### If the appropriate Assembly is already in the GAC under C:\\Windows\\Microsoft.Net\\assembly\\GAC_MSIL #####",
            "\\$AssemblyDllFilePath = [System.Reflection.Assembly]::LoadWithPartialName('System.Net.NetworkInformation').Location",
            "\\$AssemblyFullInfo = [System.Reflection.Assembly]::LoadWithPartialName('System.Net.NetworkInformation').FullName",
            "\\$AssemblyFullInfoFromDll = [System.Reflection.AssemblyName]::GetAssemblyName(\\$AssemblyDllFilePath).FullName",
            "",
            "###### If you need to download the assembly from NuGet... #####",
            "## If you are planning on running the CSharp code on .Net Framework 45 or 46 ##",
            "# Get the .dll under lib\\net45 or lib\\46...",
            "\\$NewNewtonSoftDir = \"\\$HOME\\Downloads\\NewtonSoft-JSON\"",
            "\\$NewtonSoftJsonAssemblyDllPath = \"\\$NewNewtonSoftDir\\Newtonsoft.Json.dll\"",
            "if (!\\$(Test-Path \\$NewNewtonSoftDir)) {",
            "    New-Item -ItemType Directory -Path \\$NewNewtonSoftDir",
            "    Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/Newtonsoft.Json/9.0.1\" -OutFile \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\"",
            "    Unzip-File -PathToZip \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\" -TargetDir \\$NewNewtonSoftDir -SpecificItem \"lib\\net45\\Newtonsoft.Json.dll\"",
            "}",
            "# ...and feel free to run under normal PowerShell implementation (such as PowerShell 5.1 which runs on .Net Framework 4.0)",
            "",
            "## If you are planning on running CSharp code on PowerShell Core, ##",
            "# Get the .dll under the lib\netcore50 or lib\netstandard1.X",
            "\\$NewNewtonSoftDir = \"\\$HOME\\Downloads\\NewtonSoft-JSON\"",
            "\\$NewtonSoftJsonAssemblyDllPath = \"\\$NewNewtonSoftDir\\Newtonsoft.Json.dll\"",
            "if (!\\$(Test-Path \\$NewNewtonSoftDir)) {",
            "    New-Item -ItemType Directory -Path \\$NewNewtonSoftDir",
            "    Invoke-WebRequest -Uri \"https://www.nuget.org/api/v2/package/Newtonsoft.Json/9.0.1\" -OutFile \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\"",
            "    Unzip-File -PathToZip \"\\$NewNewtonSoftDir\\newtonsoft.json.9.0.1.zip\" -TargetDir \\$NewNewtonSoftDir -SpecificItem \"lib\\netcore50\\Newtonsoft.Json.dll\"",
            "}",
            "# ...and run under PowerShell Core. ",
            "# NOTE: Dependencies are most likely radically different under for Core! It's probably easiest to build",
            "# a Visual Studio project, target .Net Core framework, use NuGet in Visual Studio to download the dependencies",
            "# and get the downloaded .dll files in \\$HOME\\.nuget\\packages",
            "",
            "# IMPORTANT NOTE: If some dependency assemblies already exist in the GAC, and the version in the GAC is",
            "# insufficient you need to remove it before installing the new version! Be very careful with removing",
            "# assemblies from the GAC. In general, NEVER remove any existing GAC assembly with \"System\" in the",
            "# AppDomain name.",
            "# (To remove, see \"\\$publish.GacRemove(\\$OldAssemblyLocation)\" below)",
            "",
            "# After downloading the new assembly, install to the GAC via the following:",
            "\\$AssemblyDllFilePath = \"\\$HOME\\Downloads\\Newtonsoft.JSON\\lib\\netstandard1.3\\Newtonsoft.Json.dll\"",
            "",
            "# Publish to the GAC using the following",
            "[System.Reflection.Assembly]::LoadWithPartialName(\"System.EnterpriseServices\")",
            "\\$publish = New-Object System.EnterpriseServices.Internal.Publish",
            "\\$publish.GacInstall(\\$AssemblyDllFilePath)",
            "#\\$publish.GacRemove(\\$OldAssemblyLocation)",
            "",
            "",
            "###### Run the inline CSharp using the Add-Type cmdlet as below #####",
            "\\$Assem = @(",
            "    \\$AssemblyFullInfo",
            ")",
            "",
            "\\$Source = @\"",
            "using System;",
            "using System.Net.NetworkInformation;",
            "",
            "namespace PaulD.IPTools",
            "{ ",
            "    public static class TCPConnections",
            "    {",
            "        public static void ShowActiveTcpConnections()",
            "        {",
            "            Console.WriteLine(\"Active TCP Connections\");",
            "            IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();",
            "            TcpConnectionInformation[] connections = properties.GetActiveTcpConnections();",
            "            foreach (TcpConnectionInformation c in connections)",
            "            {",
            "                Console.WriteLine(\"{0} <==> {1}\",",
            "                                  c.LocalEndPoint.ToString(),",
            "                                  c.RemoteEndPoint.ToString());",
            "            }",
            "        }",
            "    }",
            "}",
            "\"@",
            "",
            "Add-Type -ReferencedAssemblies \\$Assem -TypeDefinition \\$Source -Language CSharp",
            "",
            "[PaulD.IPTools.TCPConnections]::ShowActiveTcpConnections()",
            "$0"
        ],
        "description": "CSharp"
    },
    "Secure String": {
        "prefix": "securestring",
        "body": [
            "# Convert PlainText to SecureString",
            "\\$SampleSecureString = ConvertTo-SecureString 'MySuperSecretP@ssw0rd!' -AsPlainText -Force",
            "",
            "# Convert SecureString to PlainText",
            "[Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR())",
            "$0"
        ],
        "description": "Secure String"
    },
    "Send Email": {
        "prefix": "sendemail",
        "body": [
            "\\$emailParameters = @{",
            "    From = \"user@domain.com\"",
            "    To = \"user1@domain.com, User2 <user2@domain.com>\"",
            "    Subject = \"Notice of script failure\"",
            "    Body = \"The following script failed...\"",
            "    SmtpServer = \"smtp.domain.com\"",
            "    Credential = \"domain01\\admin01\"",
            "}",
            "",
            "Send-MailMessage @emailParameter",
            "$0"
        ],
        "description": "Send Email"
    },
    "Send Key": {
        "prefix": "sendkey",
        "body": [
            "# For more info on SendKeys method, see: https://msdn.microsoft.com/en-us/library/office/aa202943(v=office.10).aspx",
            "Sleep 1",
            "\\$OpenWindowTitle = \\$(Get-Process | Where-Object {\\$_.MainWindowTitle -like \"Application Install*\"}).MainWindowTitle",
            "\\$wshell = New-Object -ComObject wscript.shell",
            "\\$wshell.AppActivate(\"\\$OpenWindowTitle\") | Out-Null",
            "Sleep 1",
            "\\$wshell.SendKeys('{LEFT}')",
            "$0"
        ],
        "description": "Send Key"
    },
    "Should Process": {
        "prefix": "shouldprocess",
        "body": [
            "# Below \\$pscmdlet is type system.management.automation.pscmdlet",
            "# For good Example Usage, see Publish-MyGitRepo.ps1",
            "# For more info,, see: https://msdn.microsoft.com/en-us/library/system.management.automation.pscmdlet(v=vs.85).aspx",
            "",
            "if (\\$pscmdlet.ShouldProcess('Target','OperationMsg'))",
            "{",
            "    ",
            "}",
            "$0"
        ],
        "description": "Should Process"
    },
    "Splat Parameters": {
        "prefix": "splatparams",
        "body": [
            "\\$Params = @{",
            "    MountName = \"Installers\"",
            "    MountDriveLetter = \"\\$env:InstallersMountDriveLetter\"",
            "    NetworkPath = \"\\\\pdhyper216.pddomain2.lab\\E_Master_Share\\installers\"",
            "    UserAndPwdCredential = \\$fileshare_credential",
            "}",
            "Mount-WindowsFileShare @Params",
            "$0"
        ],
        "description": "Splat Parameters"
    },
    "Split Path": {
        "prefix": "splitpath",
        "body": [
            "\\$testpath = \"C:\\Users\\testadmin\\test.doc\"",
            "\\$ParentDir = \\$testpath | Split-Path -Parent",
            "\\$File = \\$testpath | Split-Path -Leaf",
            "$0"
        ],
        "description": "Split Path"
    },
    "Split String": {
        "prefix": "splitstring",
        "body": [
            "\\$pos = \\$PSCommandPath.LastIndexOf(\"\\\")",
            "\\$ScriptDir = \\$PSCommandPath.Substring(0, \\$pos)",
            "\\$ScriptFile = \\$PSCommandPath.Substring(\\$pos+1)",
            "$0"
        ],
        "description": "Split String"
    },
    "Switch": {
        "prefix": "switch",
        "body": [
            "# If \\$x -eq 'Value1', break; If \\$x in \\$array, do the scriptblock;",
            "# If \\$x -eq 'Value3', break; Else, do the Default scriptblock",
            "switch (\\$x)",
            "{",
            "    'Value1' {",
            "",
            "        break",
            "    }",
            "",
            "    {\\$_ -in \\$array} {}",
            "",
            "    'Value3' {",
            "",
            "        break",
            "    }",
            "    Default {}",
            "}",
            "$0"
        ],
        "description": "Switch"
    },
    "Try Catch Finally": {
        "prefix": "trycatchfinally",
        "body": [
            "<#",
            "    IMPORTANT NOTE 1: Before using try-catch-finally, make sure environment variable \\$ErrorActionPreference = \"Stop\"",
            "    as opposed to \"Continue\"",
            "",
            "    IMPORTANT NOTE 2: Find the full Error Name by using the following command immediately after failed command:",
            "    \\$Error[0].exception.GetType().fullname",
            "",
            "    IMPORTANT NOTE 3: For errors pertaining to the cmdlet Add-Type (for adding .Net Assemblies), use the following",
            "    to see what dependencies didn't load:",
            "    try",
            "    {",
            "        Add-Type -Path \"C:\\Users\\testadmin\\Downloads\\EPPlus.Core.dll\"",
            "    }",
            "    catch",
            "    {",
            "        \\$Error[0].Exception.LoaderExceptions",
            "    }",
            "#>",
            "",
            "try",
            "{",
            "    1/0",
            "    #Test-Connection bleh",
            "}",
            "catch [DivideByZeroException]",
            "{",
            "    Write-Host \"Divide by zero exception\"",
            "}",
            "catch [System.Net.NetworkInformation.PingException]",
            "{",
            "    Write-Host \"Ping exception\"",
            "}",
            "catch",
            "{",
            "    Write-Host \"General catch\"",
            "    Write-Verbose \"Error creating \\$Name on \\$Computer`:\\$([0].Exception.Message)\"",
            "}",
            "finally",
            "{",
            "    Write-Host \"cleaning up ...\"",
            "}",
            "$0"
        ],
        "description": "Try Catch Finally"
    },
    "While": {
        "prefix": "while",
        "body": [
            "while (\\$x -gt 0)",
            "{",
            "",
            "}",
            "$0"
        ],
        "description": "While"
    },
    "WinRM Config": {
        "prefix": "winrmconfig",
        "body": [
            "# Configure Service",
            "<#",
            "Set-Item -Path WSMan:\\localhost\\Service\\MaxConcurrentOperations -Value 4294967295 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\MaxConcurrentOperationsPerUser -Value 1500 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\EnumerationTimeoutms -Value 240000 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\MaxConnections -Value 300 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\MaxPacketRetrievalTimeSeconds -Value 120 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\AllowUnencrypted -Value \\$false # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\IPv4Filter -Value \"*\" # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\IPv6Filter -Value \"*\" # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\EnableCompatibilityHttpListener -Value \\$false # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\EnableCompatibilityHttpsListener -Value \\$false # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\CertificateThumbprint -Value \"\" # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\AllowRemoteAccess -Value \\$true # Configured by default",
            "#>",
            "",
            "# Configure Service Authentication",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Basic -Value \\$false # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Digest -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Kerberos -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Negotiate -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\Certificate -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Service\\Auth\\CredSSP -Value \\$false # Configured by default",
            "",
            "",
            "# Configure Client",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Basic -Value \\$false # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Digest -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Kerberos -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Negotiate -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\Certificate -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Client\\Auth\\CredSSP -Value \\$false # Configured by default",
            "#>",
            "",
            "# Configure Shell",
            "<#",
            "Set-Item -Path WSMan:\\localhost\\Shell\\AllowRemoteShellAccess -Value \\$true # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\IdleTimeout -Value 7200000 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\MaxConcurrentUsers -Value 2147483647 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\MaxShellRunTime -Value 2147483647 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\MaxProcessesPerShell -Value 2147483647 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\MaxMemoryPerShellMB -Value 2147483647 # Configured by default",
            "Set-Item -Path WSMan:\\localhost\\Shell\\MaxShellsPerUser -Value 2147483647 # Configured by default",
            "#>",
            "",
            "# Configure Trusted Hosts",
            "if (Get-Elevation) {",
            "    \\$CurrentTrustedHosts = \\$(ls WSMan:\\localhost\\Client\\TrustedHosts).Value",
            "    \\$UpdatedTrustedHostsArrayPrep = \\$CurrentTrustedHosts -split ",
            "",
            "    [System.Collections.ArrayList]\\$UpdatedTrustedHostsArray = \\$UpdatedTrustedHostsArrayPrep",
            "    \\$NeededUpdates = @()",
            "    foreach (\\$obj1 in \\$RemoteHostNetworkInfoArray) {",
            "        if (\\$UpdatedTrustedHostsArrayPrep -notcontains \\$obj1) {",
            "            \\$UpdatedTrustedHostsArray.Add(\"\\$obj1\")",
            "            \\$NeededUpdates += \\$obj1",
            "        }",
            "    }",
            "    if (\\$NeededUpdates.Count -gt 0) {",
            "        \\$UpdatedTrustedHostsArray = \\$UpdatedTrustedHostsArray | % {if (\\$_ -match \"[\\w]\") {\\$_}}",
            "        \\$UpdatedTrustedHostsArrayString = \\$UpdatedTrustedHostsArray -join ",
            "",
            "        Set-Item WSMan:\\localhost\\Client\\TrustedHosts \\$UpdatedTrustedHostsArrayString",
            "        Remove-Variable -Name NeededUpdates -Force",
            "    }",
            "    else {",
            "        Write-Host \"The current winrm config already trusts \\$RemoteHost. Continuing...\"",
            "    }",
            "}",
            "",
            "# Create New WinRM Listener",
            "New-Item -Path WSMan:\\localhost\\Listener -Address \"*\" -Transport \"HTTP\" -Port \"5985\" -Enabled \\$true -URLPrefix \"wsman\"",
            "$0"
        ],
        "description": "WinRM Config"
    },
    "WinSCP": {
        "prefix": "winscp",
        "body": [
            "if (\\$(Check-InstalledPrograms -ProgramTitleSearchTerm \"WinSCP\").DisplayName -ne ) {",
            "    Invoke-WebRequest -Uri \"https://cdn.winscp.net/files/WinSCP-5.9.5-Automation.zip?secure=FS9qKIgo7Mzm7TR6kXeRLA==,1496675795\" -OutFile \"\\$HOME\\Downloads\\WinSCP-5.9.5-Automation.zip\"",
            "    if (!\\$(Test-Path \"\\$HOME\\Downloads\\WinSCP\")) {",
            "        New-Item -Type Directory -Path \"\\$HOME\\Downloads\\WinSCP\"",
            "    }",
            "    Unzip-File -PathToZip \"\\$HOME\\Downloads\\WinSCP-5.9.5-Automation.zip\" -TargetDir \"\\$HOME\\Downloads\\WinSCP\"",
            "",
            "    # Note: Add-Type doesn't work with WinSCPnet.dll for some reason, so using .Net LoadFile method",
            "    # Add-Type \"\\$HOME\\Downloads\\WinSCP\\WinSCPnet.dll\"",
            "    [System.Reflection.Assembly]::LoadFile(\"\\$HOME\\Downloads\\WinSCP\\WinSCPnet.dll\")",
            "}",
            "$0"
        ],
        "description": "WinSCP"
    },
    "View Loaded Assemblies": {
        "prefix": "viewassemblies",
        "body": [
            "[System.AppDomain]::CurrentDomain.GetAssemblies()",
            "$0"
        ],
        "description": "View Loaded Assemblies"
    }
}
